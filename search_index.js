var documenterSearchIndex = {"docs":
[{"location":"#PackageScanner.jl","page":"PackageScanner.jl","title":"PackageScanner.jl","text":"(Image: Build Status)\n\nA comprehensive Julia package for scanning and analyzing research replication packages. PackageScanner combines PII detection, file path analysis, metadata extraction, and package validation in one tool.\n\nThis package is part of the JPE Data Editor's toolkit. Included functionality has been greatly inspired by the AEA Data Editor's replication template setup.","category":"section"},{"location":"#Features","page":"PackageScanner.jl","title":"Features","text":"","category":"section"},{"location":"#PII-Detection","page":"PackageScanner.jl","title":"PII Detection","text":"Based on the methodology from J-PAL's PII-Scan, scans variable names, labels, and code for personally identifiable information (PII) to help researchers comply with privacy regulations like GDPR. See below for legal implications.\n\nFast Stata and CSV readers: Reads only the first 1000 rows to avoid performance issues\nMulti-format data support: Uses R's rio package to read SPSS, SAS, Excel, CSV, and many other formats\nSmart detection: Minimizes false positives (e.g., names(x) vs first_name)\nCustomizable: Add your own PII search terms","category":"section"},{"location":"#Package-Analysis","page":"PackageScanner.jl","title":"Package Analysis","text":"Comprehensive tools for analyzing research replication packages:\n\nFile classification: Automatically categorizes files as code, data, or documentation\nPath detection: Identifies Windows/Unix file paths and hardcoded values in code\nFile metadata: Analyzes sizes, checksums, and detects duplicates\nREADME analysis: Parses README files (MD/PDF) for key information\nCode statistics: Integration with cloc for line counting\nReport generation: Creates markdown reports for all analyses","category":"section"},{"location":"#Installation","page":"PackageScanner.jl","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/floswald/PackageScanner.jl\")\n\nRequirements:\n\nJulia 1.10+\nR with the rio and haven packages installed\n\n# In R:\ninstall.packages(c(\"rio\", \"haven\"))\n\nOptional: cloc for code statistics (brew install cloc on macOS)","category":"section"},{"location":"#Quick-Start","page":"PackageScanner.jl","title":"Quick Start","text":"","category":"section"},{"location":"#Full-Package-Analysis","page":"PackageScanner.jl","title":"Full Package Analysis","text":"using PackageScanner\n\n# Run comprehensive analysis on a replication package\nPackageScanner.precheck_package(\"/path/to/replication-package\")\n\nThis single command performs:\n\nFile classification (code/data/docs)\nFile metadata analysis (sizes, checksums, duplicates)\nCode line counting (via cloc if available)\nFile path detection in code\nPII detection in data and code\nREADME analysis\n\nAll reports are written to generated/ folder at the package root.","category":"section"},{"location":"#PII-Scanning-Only","page":"PackageScanner.jl","title":"PII Scanning Only","text":"using PackageScanner\n\n# Define your files\ndata_files = [\"data/survey.dta\", \"data/admin.csv\"]\ncode_files = [\"src/clean.R\", \"src/analysis.py\"]\n\n# Scan for PII\ndata_results = PackageScanner.scan_data_files(data_files)\ncode_results = PackageScanner.scan_code_files(code_files)\n\n# Generate report\nPackageScanner.write_pii_report(data_results, code_results, \"output/\")","category":"section"},{"location":"#Detailed-Usage","page":"PackageScanner.jl","title":"Detailed Usage","text":"","category":"section"},{"location":"#PII-Detection-2","page":"PackageScanner.jl","title":"PII Detection","text":"# Scan a single data file\nmatches = PackageScanner.scan_data_file(\"data/survey.dta\")\n\n# Scan with strict matching (word boundaries only)\nmatches = PackageScanner.scan_data_file(\"data/survey.dta\", strict=true)\n\n# Add custom PII terms\nmatches = PackageScanner.scan_data_file(\"data/survey.dta\", custom_terms=[\"patient_id\", \"taxpayer\"])\n\n# Scan code for PII references\ncode_matches = PackageScanner.scan_code_file(\"src/analysis.R\")","category":"section"},{"location":"#File-Classification","page":"PackageScanner.jl","title":"File Classification","text":"# Classify files by type\ncode_files = PackageScanner.classify_files(\"/path/to/package\", \"code\", \"output/\")\ndata_files = PackageScanner.classify_files(\"/path/to/package\", \"data\", \"output/\")\ndocs_files = PackageScanner.classify_files(\"/path/to/package\", \"docs\", \"output/\")","category":"section"},{"location":"#File-Metadata-Analysis","page":"PackageScanner.jl","title":"File Metadata Analysis","text":"# Analyze file sizes and detect duplicates\nmetadata = PackageScanner.generate_file_sizes_md5(\"/path/to/package\", \"output/\")","category":"section"},{"location":"#Path-Detection","page":"PackageScanner.jl","title":"Path Detection","text":"# Check code files for problematic file paths\nPackageScanner.file_paths(code_files, \"output/\")","category":"section"},{"location":"#Default-PII-Terms","page":"PackageScanner.jl","title":"Default PII Terms","text":"The package searches for these terms by default (based on J-PAL PII-Scan):\n\naddress, bday, beneficiary, birth, birthday, city, dob, email,  firstname, fname, lastname, lname, name, phone, ssn, and more...\n\nSee PackageScanner.DEFAULT_PII_TERMS for the complete list.","category":"section"},{"location":"#Example-Reports","page":"PackageScanner.jl","title":"Example Reports","text":"PackageScanner generates multiple markdown reports:\n\nreport-pii.md - PII detection summary\nreport-file-paths.md - File path analysis\nreport-file-sizes.md - File metadata\nreport-duplicates.md - Duplicate files\nreport-readme.md - README analysis\nreport-cloc.md - Code statistics\nAnd more...","category":"section"},{"location":"#Contributing","page":"PackageScanner.jl","title":"Contributing","text":"Contributions welcome! Please open an issue or PR.","category":"section"},{"location":"#License","page":"PackageScanner.jl","title":"License","text":"MIT License - see LICENSE file","category":"section"},{"location":"#Acknowledgments","page":"PackageScanner.jl","title":"Acknowledgments","text":"PII detection based on J-PAL PII-Scan\nUses R's rio package for multi-format data support\nIntegrates JPEtools.jl functionality for comprehensive package analysis","category":"section"},{"location":"#What-does-GDPR-Mean-for-Researchers?","page":"PackageScanner.jl","title":"What does GDPR Mean for Researchers?","text":"There may be other legal provisions for publishing your research data beyond GDPR\n\nHere are three main things to keep in mind:\n\nRight to be Forgotten (Article 17): Researchers must be able to identify and delete an individual's data upon request. PII in datasets makes this possible - without proper tracking of identifiable information, you cannot comply with deletion requests. Conversely, inadvertently retaining PII when it should have been anonymized creates compliance risk.\nData Minimization Principle (Article 5): You should only collect and retain personal data that is adequate, relevant, and limited to what's necessary for your research purpose. A PII scanner helps identify when you're holding more identifiable information than needed - for instance, keeping full names and addresses when only age ranges and region codes would suffice for analysis.\nBreach Notification Requirements (Article 33-34): If you suffer a data breach involving personal data, you must notify authorities within 72 hours and inform affected individuals. A PII scanner helps you quickly assess what was exposed in a breach - whether it's anonymized research data (lower risk) or datasets containing names, SSNs, or other direct identifiers (high risk requiring immediate notification).\n\nBackground:\n\nFull Legal Text - EU GDPR","category":"section"},{"location":"#All-Docstrings","page":"PackageScanner.jl","title":"All Docstrings","text":"","category":"section"},{"location":"#PackageScanner.DEFAULT_PII_TERMS","page":"PackageScanner.jl","title":"PackageScanner.DEFAULT_PII_TERMS","text":"DEFAULT_PII_TERMS\n\nDefault list of PII search terms based on J-PAL PII-Scan. These terms are commonly found in variable names that contain personally identifiable information.\n\n\n\n\n\n","category":"constant"},{"location":"#PackageScanner.PIIMatch","page":"PackageScanner.jl","title":"PackageScanner.PIIMatch","text":"PIIMatch\n\nA structure representing a detected PII match.\n\nFields\n\nfilepath::String: Path to the file containing the match\nvariable_name::String: Name of the variable or line identifier\nvariable_label::Union{String, Nothing}: Variable label (if available)\nmatched_terms::Vector{String}: PII terms that matched\nsample_values::Vector{String}: Sample values from the data\n\n\n\n\n\n","category":"type"},{"location":"#PackageScanner.check_file_paths-Tuple{Any}","page":"PackageScanner.jl","title":"PackageScanner.check_file_paths","text":"check_file_paths(filepath)\n\nRead each line of code and analyze. Looking for file paths and hardcoded numeric constants. Returns: (lines, classification, has_drive, hardcodes)\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.classify_files-Tuple{String, String, String}","page":"PackageScanner.jl","title":"PackageScanner.classify_files","text":"classify_files(pkg_path::String, kind::String, fp::String; relpath = false)\n\nCount how many files belong to each of code, data, documentation according to their file ending.\n\nArguments\n\npkg_path: path to (extracted) replication package\nkind: what kind of classification is desired: code, data, docs\nfp: output folder path\n\nOutputs txt files into folder fp which will be created if needed.\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.create_example_package-Tuple{String}","page":"PackageScanner.jl","title":"PackageScanner.create_example_package","text":"create_example_package(at_root::String)\n\nCreate an example test package structure for testing purposes.\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.detect_path_kinds-Tuple{String}","page":"PackageScanner.jl","title":"PackageScanner.detect_path_kinds","text":"detect_path_kinds(line::String)\n\nDetects all relevant path patterns in a line of code. Returns tuple: (windows, unix, drive_letter)\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.extract_metadata-Tuple{Any}","page":"PackageScanner.jl","title":"PackageScanner.extract_metadata","text":"extract_metadata(data)\n\nExtract metadata from a dataset, including variable names, labels, and sample values. Works with DataFrames, Dicts, and other tabular objects.\n\nArguments\n\ndata: A dataset (DataFrame, Dict, CSV.File, etc.)\nlabels: Optional variable labels\n\nReturns\n\nDict with keys: var_names, var_labels, samples\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.file_paths-Tuple{Array, String}","page":"PackageScanner.jl","title":"PackageScanner.file_paths","text":"file_paths(files::Array, fp::String)\n\nTakes an array of file paths, reads each associated file and checks its content for  the existence of file paths of various kinds: windows C:\\file\\paths\\like\\this  or unix /paths/like/that. Also searches for numeric constants which could be hardcoded results.\n\nOutputs three markdown files into fp with partial reports.\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.find_pii_terms-Tuple{String, Vector{String}}","page":"PackageScanner.jl","title":"PackageScanner.find_pii_terms","text":"find_pii_terms(text::String, search_terms::Vector{String}; strict::Bool=false)\n\nSearch for PII terms in text string.\n\nArguments\n\ntext::String: Text to search\nsearch_terms::Vector{String}: List of PII terms to search for\nstrict::Bool=false: If true, use word boundary matching\n\nReturns\n\nVector{String}: List of matched terms\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.findfile-Tuple{Any, Any}","page":"PackageScanner.jl","title":"PackageScanner.findfile","text":"findfile(directory, file; casesensitive = true)\n\nFind one specific file in the tree.\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.generate_detailed_appendix-Tuple{Vector{PackageScanner.PIIMatch}, Vector{PackageScanner.PIIMatch}}","page":"PackageScanner.jl","title":"PackageScanner.generate_detailed_appendix","text":"generate_detailed_appendix(data_results::Vector{PIIMatch}, code_results::Vector{PIIMatch}; splitat=nothing)\n\nGenerate detailed markdown listing of all PII detections.\n\nArguments\n\ndata_results::Vector{PIIMatch}: Data file PII matches\ncode_results::Vector{PIIMatch}: Code file PII matches\nsplitat::Union{String,Nothing}=nothing: Optional string to split paths at\n\nReturns\n\nString: Markdown formatted detailed listing\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.generate_file_sizes_md5-Tuple{String, String}","page":"PackageScanner.jl","title":"PackageScanner.generate_file_sizes_md5","text":"generate_file_sizes_md5(folder_path::String, output_path::String; large_size = 100)\n\nRead entire package content and tabulate file sizes with file hash to check for duplicates.\n\nArguments\n\nfolder_path: Path to scan\noutput_path: Where to write reports\nlarge_size: Threshold in MB for \"large\" files (default: 100)\n\nReturns a DataFrame with file metadata.\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.generate_summary_table-Tuple{Vector{PackageScanner.PIIMatch}, Vector{PackageScanner.PIIMatch}}","page":"PackageScanner.jl","title":"PackageScanner.generate_summary_table","text":"generate_summary_table(data_results::Vector{PIIMatch}, code_results::Vector{PIIMatch})\n\nGenerate a markdown summary table of PII detections.\n\nArguments\n\ndata_results::Vector{PIIMatch}: Data file PII matches\ncode_results::Vector{PIIMatch}: Code file PII matches\n\nReturns\n\nString: Markdown formatted table\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.getPDFText-Tuple{Any, Any}","page":"PackageScanner.jl","title":"PackageScanner.getPDFText","text":"getPDFText(src, out) -> Dict\n\nExtract text from a PDF file.\n\nArguments\n\nsrc: Input PDF file path from where text is to be extracted\nout: Output TXT file path where the output will be written\n\nReturns a dictionary containing metadata of the document.\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.hardcode_regex-Tuple{}","page":"PackageScanner.jl","title":"PackageScanner.hardcode_regex","text":"hardcode_regex()\n\nRegular expression for detecting hardcoded numeric constants.\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.is_false_positive_context-Tuple{String}","page":"PackageScanner.jl","title":"PackageScanner.is_false_positive_context","text":"is_false_positive_context(line::String)\n\nCheck if a line of code represents a false positive context.\n\nArguments\n\nline::String: Line of code to check\n\nReturns\n\nBool: true if line is likely a false positive\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.is_unix_filepath-Tuple{String}","page":"PackageScanner.jl","title":"PackageScanner.is_unix_filepath","text":"is_unix_filepath(line::String)\n\nFind a Unix filepath, omitting various comment and command strings. Looks for patterns like: here/we/have/a_/1234/unix-1/path\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.is_windows_filepath-Tuple{String}","page":"PackageScanner.jl","title":"PackageScanner.is_windows_filepath","text":"is_windows_filepath(line::String)\n\nFind a Windows filepath, omitting various comment and command strings. Looks for patterns like: this\\is\\123\\a\\path-yes\\1t\\is\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.load_data_metadata","page":"PackageScanner.jl","title":"PackageScanner.load_data_metadata","text":"load_data_metadata(filepath::String, max_rows = 1000)\n\nLoad metadata from a data file. For CSV files, uses Julia's CSV package. For other file types, uses R's rio package. Returns a dictionary with variable names, labels, and sample values, or nothing if the file cannot be loaded.\n\nArguments\n\nfilepath::String: Path to the data file\nmax_rows::Int: Maximum number of rows to read (default: 1000)\n\nReturns\n\nDict with keys: var_names, var_labels, samples\nnothing if file cannot be loaded\n\nExamples\n\nmetadata = load_data_metadata(\"data/survey.dta\")\nprintln(metadata[\"var_names\"])\n\n\n\n\n\n","category":"function"},{"location":"#PackageScanner.path_splitter-Tuple{String, Any}","page":"PackageScanner.jl","title":"PackageScanner.path_splitter","text":"path_splitter(path::String, at)\n\nSplit a path at a specific delimiter.\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.precheck_package-Tuple{String}","page":"PackageScanner.jl","title":"PackageScanner.precheck_package","text":"precheck_package(pkg_loc::String)\n\nComprehensive check of a replication package in directory pkg_loc.\n\nIt is assumed that pkg_loc is descendant in a directory structure of this kind,  i.e. what is implemented in https://github.com/JPE-Reproducibility/JPEtemplate\n\nIn this example, pkg_loc = abspath(replication-package):\n\n.\n├── generated\n├── images\n├── LICENSE\n├── replication-package\n├── package-output-map.xlsx\n├── README.md\n└── TEMPLATE.qmd\n\nArguments\n\npkg_loc: Path to the replication package directory\n\nPerforms\n\nFile classification (code/data/docs)\nFile metadata analysis (sizes, checksums, duplicates)\nCode line counting (via cloc)\nFile path analysis in code files\nPII detection in data and code files\nREADME analysis\n\nAll reports are written to generated/ folder at the package root.\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.rdir-Tuple{AbstractString, Glob.FilenameMatch}","page":"PackageScanner.jl","title":"PackageScanner.rdir","text":"rdir(dir::AbstractString, pat::Glob.FilenameMatch)\n\nRecursively search a directory tree for files matching the pattern.\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.read_README-Tuple{Any, String}","page":"PackageScanner.jl","title":"PackageScanner.read_README","text":"read_README(pkg_loc, fp::String)\n\nFind the README in the package and read from either .md or .pdf format.  Then produce a report with mentions of interesting terms like software used,  whether confidential, etc.\n\nArguments\n\npkg_loc: Package location\nfp: Output folder path\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.read_and_unzip_directory-Tuple{String}","page":"PackageScanner.jl","title":"PackageScanner.read_and_unzip_directory","text":"read_and_unzip_directory(dir_path::String)\n\nRead contents of a directory and unzip any .zip files using system unzip command. Extracts zip files to the same directory where they reside.\n\nArguments\n\ndir_path::String: Path to the directory to read\n\nReturns\n\nVector{String}: All file paths in the directory (after unzipping)\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.scan_code_file-Tuple{String}","page":"PackageScanner.jl","title":"PackageScanner.scan_code_file","text":"scan_code_file(filepath::String; strict::Bool=false, custom_terms::Vector{String}=String[])\n\nScan a code file for PII term references.\n\nArguments\n\nfilepath::String: Path to code file\nstrict::Bool=false: Use strict word boundary matching\ncustom_terms::Vector{String}=String[]: Additional PII terms to search for\n\nReturns\n\nVector{PIIMatch}: List of detected PII references\n\nExamples\n\nmatches = scan_code_file(\"src/analysis.R\")\nmatches = scan_code_file(\"src/analysis.R\", strict=true)\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.scan_code_files-Tuple{Vector{String}}","page":"PackageScanner.jl","title":"PackageScanner.scan_code_files","text":"scan_code_files(code_files::Vector{String}; strict::Bool=false, custom_terms::Vector{String}=String[])\n\nScan multiple code files for PII references.\n\nArguments\n\ncode_files::Vector{String}: Vector of code file paths\nstrict::Bool=false: Use strict word boundary matching\ncustom_terms::Vector{String}=String[]: Additional PII terms\n\nReturns\n\nVector{PIIMatch}: All detected PII references across files\n\nExamples\n\ncode_files = [\"src/clean.R\", \"src/analysis.py\"]\nmatches = scan_code_files(code_files)\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.scan_data_file-Tuple{String}","page":"PackageScanner.jl","title":"PackageScanner.scan_data_file","text":"scan_data_file(filepath::String; strict::Bool=false, custom_terms::Vector{String}=String[])\n\nScan a data file for PII indicators in variable names and labels.\n\nArguments\n\nfilepath::String: Path to data file\nstrict::Bool=false: Use strict word boundary matching\ncustom_terms::Vector{String}=String[]: Additional PII terms to search for\n\nReturns\n\nVector{PIIMatch}: List of detected PII matches\n\nExamples\n\nmatches = scan_data_file(\"data/survey.dta\")\nmatches = scan_data_file(\"data/survey.dta\", strict=true)\nmatches = scan_data_file(\"data/survey.dta\", custom_terms=[\"patient_id\"])\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.scan_data_files-Tuple{Vector{String}}","page":"PackageScanner.jl","title":"PackageScanner.scan_data_files","text":"scan_data_files(data_files::Vector{String}; strict::Bool=false, custom_terms::Vector{String}=String[])\n\nScan multiple data files for PII indicators.\n\nArguments\n\ndata_files::Vector{String}: Vector of data file paths\nstrict::Bool=false: Use strict word boundary matching\ncustom_terms::Vector{String}=String[]: Additional PII terms\n\nReturns\n\nVector{PIIMatch}: All detected PII matches across files\n\nExamples\n\ndata_files = [\"data/survey.dta\", \"data/admin.csv\"]\nmatches = scan_data_files(data_files)\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.write_pii_report-Tuple{Vector{PackageScanner.PIIMatch}, Vector{PackageScanner.PIIMatch}, String}","page":"PackageScanner.jl","title":"PackageScanner.write_pii_report","text":"write_pii_report(data_results, code_results, output_dir; kwargs...)\n\nWrite PII detection reports (main summary and detailed appendix).\n\nArguments\n\ndata_results::Vector{PIIMatch}: Data file PII matches\ncode_results::Vector{PIIMatch}: Code file PII matches\noutput_dir::String: Directory to write reports to\n\nKeyword Arguments\n\nsplitat::Union{String,Nothing}=nothing: String to split file paths at\nmain_file::String=\"report-pii.md\": Name of main report file\nappendix_file::String=\"report-pii-appendix.md\": Name of appendix file\n\nExamples\n\nwrite_pii_report(data_results, code_results, \"/output\", splitat=\"/project/\")\n\n\n\n\n\n","category":"method"},{"location":"#PackageScanner.write_pii_report_simple-Tuple{Vector{PackageScanner.PIIMatch}, Vector{PackageScanner.PIIMatch}, String}","page":"PackageScanner.jl","title":"PackageScanner.write_pii_report_simple","text":"write_pii_report_simple(data_results, code_results, fp; splitat=nothing)\n\nWrite single PII report in simple bullet-list format.\n\nArguments\n\ndata_results::Vector{PIIMatch}: Data file PII matches\ncode_results::Vector{PIIMatch}: Code file PII matches  \nfp::String: Directory to write report to\nsplitat::Union{String,Nothing}=nothing: String to split file paths at\n\nExamples\n\nwrite_pii_report_simple(data_results, code_results, \"/output\")\n\n\n\n\n\n","category":"method"}]
}
